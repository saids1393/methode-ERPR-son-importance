// app/api/cron/process-second-payments/route.ts
import { NextResponse } from "next/server";
import { stripe } from "@/lib/stripe";

export async function GET(req: Request) {
  try {
    // V√©rifier l'authentification (secret token)
    const authHeader = req.headers.get("authorization");
    if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    console.log("üîÑ Ex√©cution du cron - Traitement des paiements 2x...");

    // üìÖ Chercher les 1ers paiements r√©ussis depuis 30 jours
    const thirtyDaysInSeconds = 30 * 24 * 60 * 60; // 30 jours
    const thirtyDaysAgo = Math.floor(Date.now() / 1000) - thirtyDaysInSeconds;

    console.log(
      `üìÖ Recherche des paiements depuis ${new Date(
        thirtyDaysAgo * 1000
      ).toLocaleString()}`
    );

    // R√©cup√©rer tous les PaymentIntents cr√©√©s dans les derni√®res 30 jours
    const paymentIntents = await stripe.paymentIntents.list({
      limit: 100,
      created: {
        gte: thirtyDaysAgo,
        lte: Math.floor(Date.now() / 1000),
      },
    });

    console.log(`üìä ${paymentIntents.data.length} paiements √† v√©rifier`);

    const results = [];

    for (const pi of paymentIntents.data) {
      // V√©rifier si c'est un 1er paiement 2x r√©ussi
      if (
        pi.metadata?.paymentPlan === "2x" &&
        pi.metadata?.paymentNumber === "1" &&
        pi.status === "succeeded"
      ) {
        const customerId = pi.customer as string;
        const email = pi.metadata.email;

        console.log(`üí≥ Traitement du 2e paiement pour ${email}`);

        // V√©rifier si le 2√®me paiement a d√©j√† √©t√© effectu√©
        const existingSecondPayments = await stripe.paymentIntents.list({
          customer: customerId,
          limit: 10,
        });

        const alreadyPaid = existingSecondPayments.data.some(
          (p) =>
            p.metadata?.paymentPlan === "2x" &&
            p.metadata?.paymentNumber === "2" &&
            p.status === "succeeded"
        );

        if (alreadyPaid) {
          console.log(`‚úÖ ${email} : 2√®me paiement d√©j√† effectu√©, skip`);
          continue;
        }

        // Lancer le 2e paiement
        try {
          const baseUrl =
            process.env.NODE_ENV === "production"
              ? process.env.NEXTAUTH_URL
              : "http://localhost:3000";

          const response = await fetch(
            `${baseUrl}/api/stripe/charge-second-payment`,
            {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ customerId, email }),
            }
          );

          const result = await response.json();

          if (result.success) {
            console.log(`‚úÖ 2√®me paiement r√©ussi pour ${email} : ${result.amount}‚Ç¨`);
            results.push({ email, status: "success", amount: result.amount });
          } else {
            console.error(`‚ùå √âchec 2√®me paiement pour ${email}:`, result.error);
            results.push({ email, status: "failed", error: result.error });
          }
        } catch (err: any) {
          console.error(`‚ùå Erreur lors du 2√®me paiement pour ${email}:`, err.message);
          results.push({ email, status: "error", error: err.message });
        }
      }
    }

    console.log(`üéâ Cron termin√© : ${results.length} paiements trait√©s`);

    return NextResponse.json({
      success: true,
      processed: results.length,
      results,
      timestamp: new Date().toISOString(),
    });
  } catch (error: any) {
    console.error("‚ùå Erreur cron job:", error.message);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

// Pour tests manuels en d√©veloppement
export async function POST(req: Request) {
  if (process.env.NODE_ENV === "production") {
    return NextResponse.json(
      { error: "POST not allowed in production" },
      { status: 405 }
    );
  }
  return GET(req);
}